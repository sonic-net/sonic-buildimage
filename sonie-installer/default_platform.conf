#!/bin/sh
################################################################################
# default_platform.conf
#
# Default platform implementation for the SONiE installer.
#
# This script is sourced by install.sh and provides the default implementations
# for platform-specific operations such as:
#   - Initializing console settings
#   - Partitioning the storage device
#   - Creating and mounting filesystems
#   - Installing the bootloader
#   - Configuring the bootloader menu
#
# Functions defined here can be overridden by specific platform configurations
# if needed, but this file serves as the baseline for most generic UEFI
# platforms.
#
# Globals:
#   CONSOLE_PORT (string): Serial console port (default: 0x3f8)
#   CONSOLE_SPEED (string): Serial console speed (default: 9600)
#   CONSOLE_DEV (string): Serial console device index (default: 0)
#   sonie_part_size (int): Size of the SONIE partition in MB
#   sonie_volume_label (string): Label for the SONIE partition
#   sonie_volume_revision_label (string): Revision-specific label
#   sonie_mnt (string): Mount point for the SONIE partition
#   sonie_part_num (int): Partition number for SONIE
#   sonie_type (string): Installation type (OS, DIAG, etc.)
#   install_env (string): Current installation environment (onie, sonic, build, sonie)
#   onie_bin (string): Path to ONIE binary
#   onie_initrd_tmp (string): Path to ONIE initrd temporary directory
#   onie_root_dir (string): Root directory of ONIE
#   firmware (string): Firmware type (uefi, bios)
#   image_dir (string): Directory for the image
#   FILESYSTEM_SQUASHFS (string): Name of the squashfs file
#   VAR_LOG_SIZE (int): Size of /var/log
#   check_var_log_size (function): Function to check log size
################################################################################

#######################################
# Initializes console settings (port, speed, dev) from defaults or kernel cmdline.
# Globals:
#   CONSOLE_PORT
#   CONSOLE_DEV
#   CONSOLE_SPEED
# Arguments:
#   None
# Returns:
#   None
#######################################
init_console_settings() {
  local cmdline
  if [ -r /proc/cmdline ]; then
    cmdline=$(cat /proc/cmdline)
  else
    cmdline=""
  fi
  if [ -z "${CONSOLE_PORT:-}" ]; then
    local console_ttys
    console_ttys=$(echo "$cmdline" | grep -Eo 'console=ttyS[0-9]+' | cut -d "=" -f2 | head -n 1)
    case "$console_ttys" in
      "ttyS1")
        CONSOLE_PORT=0x2f8
        CONSOLE_DEV=1
        ;;
      "ttyS2")
        CONSOLE_PORT=0x3e8
        CONSOLE_DEV=2
        ;;
      "ttyS3")
        CONSOLE_PORT=0x2e8
        CONSOLE_DEV=3
        ;;
      *)
        # Default to ttyS0
        CONSOLE_PORT=0x3f8
        CONSOLE_DEV=0
        ;;
    esac
  fi
  if [ -z "${CONSOLE_SPEED:-}" ]; then
    local speed
    speed=$(echo "$cmdline" | grep -Eo 'console=ttyS[0-9]+,[0-9]+' | cut -d "," -f2 | head -n 1)
    CONSOLE_SPEED="${speed:-9600}"
  fi
  # Export these so they are available to the caller
  export CONSOLE_PORT CONSOLE_DEV CONSOLE_SPEED
}
init_console_settings

#######################################
# Resolves the parent block device from a partition name.
# Globals:
#   None
# Arguments:
#   part_path: Path or name of the partition (e.g., /dev/sda1)
# Outputs:
#   Writes the parent block device path to stdout.
#######################################
find_device_from_partdev() {
  local partdev="${1##*/}"
  local sys_base="${SYSFS_BASE:-/sys/class/block}"
  # Check if sysfs exists for this device
  if [ -d "${sys_base}/${partdev}" ]; then
    # Go to sysfs directory, cd up one level to find parent, and print its name
    # shell check disable=SC2005
    echo "/dev/$(cd -P "${sys_base}/${partdev}" && cd .. && echo "${PWD##*/}")"
  fi
}
#######################################
# Constructs a partition device path from a block device and partition number.
# Handles suffix logic (e.g., nvme0n1 -> nvme0n1p1, sda -> sda1).
# Globals:
#   None
# Arguments:
#   dev: Block device path (e.g., /dev/sda, /dev/nvme0n1)
#   num: Partition number
# Outputs:
#   Writes the partition device path to stdout.
#######################################
make_partition_dev() {
  local dev="$1"
  local num="$2"
  case "$dev" in
    *[0-9]) echo "${dev}p${num}" ;;
    *) echo "${dev}${num}" ;;
  esac
}

#######################################
# Detects the primary block device for installation.
# Globals:
#   blk_dev
#   discovery_dev
#   cur_part
# Arguments:
#   None
#######################################
detect_block_device() {
  discovery_dev=$(blkid -o export | awk -F= '
    $1 == "DEVNAME" { dev = $2 }
    ($1 == "LABEL" || $1 == "PARTLABEL") && $2 ~ /^(ONIE-BOOT|XBOOTLDR|SONIE-)/ { print dev; exit }
  ')

  # Robustly determine block device from partition using sysfs
  if [ -n "$discovery_dev" ]; then
    blk_dev=$(find_device_from_partdev "$discovery_dev")
  fi

  # Fallback detection for empty/corrupted disk if blkid failed
  if [ -z "$blk_dev" ]; then
    for dev in /dev/sda /dev/vda /dev/nvme0n1; do
      if [ -b "$dev" ]; then
        blk_dev="$dev"
        echo "Detected fallback device: $blk_dev"
        break
      fi
    done
  fi

  [ -b "$blk_dev" ] || {
    echo "Error: Unable to determine block device of ONIE install"
    exit 1
  }

  # Note: ONIE has no mount setting for / with device node, so below will be empty string
  cur_part=""
  if [ -r /proc/mounts ]; then
    cur_part=$(awk -v bd="$blk_dev" '$2=="/" && $1 ~ bd {print $1}' /proc/mounts)
  fi
}

#######################################
# Checks if the detected block device requires reformatting.
# Globals:
#   discovery_dev
#   blk_dev
# Arguments:
#   None
# Returns:
#   0 if formatting is needed, 1 otherwise.
#######################################
disk_needs_formatting() {
  # If we found an existing ONIE/SONiC partition, the table is valid.
  if [ -n "$discovery_dev" ]; then
    return 1
  fi

  # Check if partition table is valid using sgdisk
  if verify_out=$(sgdisk -v "$blk_dev" 2>&1) && ! echo "$verify_out" | grep -q 'entries is 0 bytes'; then
    echo "Partition table valid."
    return 1
  fi

  echo "Partition table invalid or unknown."
  return 0
}

#######################################
# Creates the necessary partitions for SONIE installation.
# Auto-detects ONIE/SONIE device or falls back to standard block devices.
# Globals:
#   install_env
#   onie_bin
#   firmware
#   blk_dev
# Arguments:
#   None
# Returns:
#   None
#######################################
create_partition()
{
  if [ "$install_env" = "build" ]; then
    return
  fi

  detect_block_device

  # auto-detect whether BIOS or UEFI
  if [ -d "/sys/firmware/efi/efivars" ] ; then
    firmware="uefi"
  else
    echo "Error: BIOS is unsupported"
    exit 1
  fi

  if [ "$install_env" = "onie" ] || [ "$install_env" = "sonie" ] || [ "$install_env" = "sonic" ]; then
    if disk_needs_formatting; then
      echo "Reformatting ${blk_dev}..."
      sgdisk -Z "$blk_dev"
      sgdisk -o "$blk_dev"
      sgdisk -n 1:2048:+2G -c 1:"ESP" -t 1:ef00 "$blk_dev"
      partprobe "$blk_dev" || true
      if [ -x "$(command -v mkfs.vfat)" ]; then
        mkfs.vfat -F 32 -n "ESP" "$(make_partition_dev "$blk_dev" 1)"
      fi
    fi
    create_sonie_uefi_partition "$blk_dev"
  fi
}
#######################################
# Mounts the sonie partition and prepares it for installation.
# Globals:
#   blk_dev
#   sonie_part
#   sonie_mnt
#   sonie_volume_label
# Arguments:
#   None
# Returns:
#   None
#######################################
mount_partition()
{
  local sonie_dev
  sonie_dev=$(make_partition_dev "$blk_dev" "$sonie_part")
  # Make filesystem
  mkfs.vfat -F 32 -n "$sonie_volume_label" "$sonie_dev"
  # Mount sonie filesystem
  sonie_mnt=$(${onie_bin} mktemp -d) || {
    echo "Error: Unable to create file system mount point"
    exit 1
  }
  trap_push "${onie_bin} fuser -km $sonie_mnt || ${onie_bin} umount $sonie_mnt || ${onie_bin} rmdir $sonie_mnt || true"
  ${onie_bin} mount -t vfat -o defaults,rw,umask=0000 "$sonie_dev" "$sonie_mnt" || {
    echo "Error: Unable to mount $sonie_dev on $sonie_mnt"
    exit 1
  }
}

sonie_part=""
#######################################
# Creates a GPT partition for the sonie OS.
# Handles partition re-use and cleanup of collisions (by label).
# Globals:
#   sonie_volume_label
#   sonie_part
# Arguments:
#   blk_dev (string): Block device (e.g. /dev/sda)
# Returns:
#   None
#######################################
create_sonie_gpt_partition()
{
  local blk_dev="$1"
  local sonie_partitions
  local reuse_part=""

  # Search for SONIE-OS, or XBOOTLDR partitions to remove duplicates
  sonie_partitions=$(sgdisk -p "$blk_dev" | grep -e "$sonie_volume_label" -e "XBOOTLDR" | awk '{print $1}')

  if [ -n "$sonie_partitions" ] ; then
    # Check if we can reuse an existing XBOOTLDR partition
    for part_index in $sonie_partitions; do
      if [ "$(make_partition_dev "$blk_dev" "$part_index")" = "$cur_part" ]; then continue; fi

      # Check label
      local part_label
      part_label=$(sgdisk -i "$part_index" "$blk_dev" | grep "Partition name:" | sed "s/.*'\(.*\)'.*/\1/")

      # Only reuse if label is explicitly XBOOTLDR
      if [ "$part_label" = "XBOOTLDR" ]; then
        # Check size
        local part_sectors
        local sector_size
        local part_size_mb

        # Extract sectors - "Partition size: 123456 sectors ..."
        part_sectors=$(sgdisk -i "$part_index" "$blk_dev" | grep "Partition size:" | awk '{print $3}')

        # Get sector size (default 512 if not found, though sgdisk usually reports it)
        sector_size=$(sgdisk -p "$blk_dev" | grep "Sector size" | awk -F: '{print $2}' | awk -F/ '{print $1}' | tr -d ' ')
        sector_size=${sector_size:-512}

        # Calculate MB: sectors * sector_size / 1024 / 1024
        part_size_mb=$(( (part_sectors * sector_size) / 1048576 ))

        echo "Found XBOOTLDR partition $part_index: ${part_size_mb} MB (Required: ${sonie_part_size} MB)"

        if [ "$part_size_mb" -ge "$sonie_part_size" ]; then
           echo "Reusing existing XBOOTLDR partition $part_index"
           reuse_part="$part_index"
           break
        fi
      fi
    done

    # delete existing partitions (duplicates or too small)
    for part_index in $sonie_partitions; do
      if [ "$(make_partition_dev "$blk_dev" "$part_index")" = "$cur_part" ]; then continue; fi

      # Skip our chosen reuse partition
      if [ "$part_index" = "$reuse_part" ]; then continue; fi

      echo "deleting partition $part_index ..."
      # if the partition is already mounted, umount first
      if df "$(make_partition_dev "$blk_dev" "$part_index")" >/dev/null 2>&1; then
        umount "$(make_partition_dev "$blk_dev" "$part_index")" || {
          echo "Error: Unable to umount $(make_partition_dev "$blk_dev" "$part_index")"
          exit 1
        }
      fi
      sgdisk -d "$part_index" "$blk_dev" || {
        echo "Error: Unable to delete partition $part_index on $blk_dev"
        exit 1
      }
      partprobe || {
        echo "Error: Unable to partprobe"
      }
    done
  fi

  local part_label="XBOOTLDR"
  local part_type="ea00"
  local attr_bitmask="0x0"
  if [ "$sonie_type" = "DIAG" ] ; then
    # set the GPT 'system partition' attribute bit for the DIAG
    # partition.
    attr_bitmask="0x1"
  fi

  if [ -n "$reuse_part" ]; then
    sonie_part="$reuse_part"
    echo "Updating reused partition $sonie_part attributes..."
  else
    local all_part
    # ASSUME: there are no more than 99999 partitions in a block device
    all_part=$(sgdisk -p "$blk_dev" | awk "{if (\$1 > 0 && \$1 <= 99999) print \$1}")
    # Find next available partition
    local used_part
    sonie_part=1
    for used_part in $all_part; do
      # echo "Partition #$used_part is in use."
      # skip if used_part is empty or not a number
      [ -z "$used_part" ] || [ -z "${used_part##*[!0-9]*}" ] && continue
      if [ "$used_part" -ne "$sonie_part" ]; then break; fi
      sonie_part=$((sonie_part + 1))
    done
    echo "Partition #$sonie_part is available"

    echo "Creating new $part_label partition $(make_partition_dev "$blk_dev" "$sonie_part") (Type: $part_type) ..."

    # Create new partition
    # Try preferred partition number first
    if ! sgdisk --new=${sonie_part}::+${sonie_part_size}MB \
      --attributes=${sonie_part}:=:$attr_bitmask \
      --typecode=${sonie_part}:$part_type \
      --change-name=${sonie_part}:$part_label "$blk_dev"; then
           echo "Warning: The first trial of creating partition failed, trying the largest aligned available block of sectors on the disk"
      local begin end
      begin=$(sgdisk -F "$blk_dev")
      end=$(sgdisk -E "$blk_dev")
      sgdisk --new=${sonie_part}:$begin:$end \
        --attributes=${sonie_part}:=:$attr_bitmask \
        --typecode=${sonie_part}:$part_type \
        --change-name=${sonie_part}:$part_label "$blk_dev" || {
        echo "Error: Unable to create partition $sonie_part on $blk_dev"
        exit 1
      }
    fi
  fi

  # Always update name and attributes for partition to ensure they are correct (redundant but safe)
  sgdisk --attributes=${sonie_part}:=:$attr_bitmask \
     --typecode=${sonie_part}:$part_type \
     --change-name=${sonie_part}:$part_label "$blk_dev" || true
  partprobe || true
}
#######################################
# Creates a UEFI partition by wrapping GPT creation and cleaning boot vars.
# Globals:
#   sonie_volume_label
# Arguments:
#   blk_dev (string): Block device
# Returns:
#   None
#######################################
create_sonie_uefi_partition()
{
  create_sonie_gpt_partition "$1"
  # erase any related EFI BootOrder variables from NVRAM.
  # Clean up current label, plus legacy labels (ACS-OS, SONiC-OS) and ONIE (replacing bootloader).
  # Skip cleanup if running in Sonie environment to preserve existing boot entries
  if [ "${install_env}" != "sonie" ]; then
      for b in $(efibootmgr | grep -e "$sonie_volume_label" -e "ACS-OS" -e "SONiC-OS" -e "ONIE" | awk '{ print $1 }') ; do
        local num=${b#Boot}
        # Remove trailing '*'
        num=${num%\*}
        efibootmgr -b $num -B > /dev/null 2>&1
      done
  fi
}
#######################################
# Installs GRUB to the EFI System Partition (ESP).
# Arguments:
#   blk_dev (string): Block device
#   esp_mnt (string): ESP mount point
#   os_mnt (string): OS partition mount point
# Returns:
#   None
#######################################
install_grub_to_esp()
{
  local blk_dev="$1"
  local esp_mnt="$2"
  local os_mnt="$3"
  echo "Installing GRUB to ESP at $esp_mnt..."

  local grub_args=("--target=x86_64-efi" "--efi-directory=${esp_mnt}" "--boot-directory=${os_mnt}" "--bootloader-id=${sonie_volume_label}" "--recheck" "--modules=part_gpt part_msdos")
  
  if [ "${install_env}" = "sonie" ]; then
      grub_args+=("--no-nvram")
  fi

  grub-install "${grub_args[@]}" "$blk_dev"

  echo "Generating GRUB config..."
  local grub_cfg="$os_mnt/grub/grub.cfg"

  # Find UKI in OS partition
  local uki_path="/linux.efi"
  local found_uki=$(find "$os_mnt" -maxdepth 1 \( -name "*.efi" -o -name "*.bin" \) -type f | head -n 1)
  if [ -n "$found_uki" ]; then
    uki_path="/$(basename "$found_uki")"
  fi

  # Helper: Read platform settings
  local CPUVENDOR=""
  if [ -r /proc/cpuinfo ]; then
    CPUVENDOR=$(grep -m 1 vendor_id /proc/cpuinfo | awk '{print $3}')
  fi

  local CSTATES=""
  if echo "$CPUVENDOR" | grep -iq 'Intel'; then
    CSTATES="processor.max_cstate=1 intel_idle.max_cstate=0"
  fi

  # Setup defaults corresponding to platform.conf expectations
  local DEFAULT_GRUB_SERIAL_COMMAND="serial --port=${CONSOLE_PORT:-0x3f8} --speed=${CONSOLE_SPEED:-115200} --word=8 --parity=no --stop=1"
  local DEFAULT_GRUB_CMDLINE_LINUX="console=tty0 console=ttyS${CONSOLE_DEV:-0},${CONSOLE_SPEED:-115200}n8 quiet $CSTATES"

  # Use globals if set, else default
  GRUB_SERIAL_COMMAND="${GRUB_SERIAL_COMMAND:-$DEFAULT_GRUB_SERIAL_COMMAND}"
  GRUB_CMDLINE_LINUX="${GRUB_CMDLINE_LINUX:-$DEFAULT_GRUB_CMDLINE_LINUX}"

  export GRUB_SERIAL_COMMAND
  export GRUB_CMDLINE_LINUX

  # Determine if we should merge with existing config
  local existing_cfg=""
  if [ "${install_env}" != "build" ]; then
      # Look for existing grub.cfg in ESP to merge with
      existing_cfg=$(find "${esp_mnt}" -name grub.cfg 2>/dev/null | grep -v "${grub_cfg}" | head -n 1)
      if [ -f "${existing_cfg}" ]; then
          log_info "Merging with existing config at ${existing_cfg}"
      else
         log_warn "No existing grub.cfg found in ESP to merge."
      fi
  fi

  # Write Header
  cat <<EOF > "$grub_cfg"
$GRUB_SERIAL_COMMAND
terminal_input serial
terminal_output serial
set timeout=5
EOF
  
  # Merge Existing Entries if found
  if [ -n "${existing_cfg}" ] && [ -f "${existing_cfg}" ]; then
      # Parse and extract bodies
      # We use awk to extract bodies of 'menuentry ... {' blocks
      # We ignore the label in the file and relabel them SONIC_A, SONIC_B
      awk '
        BEGIN { count=0 }
        /^menuentry / { 
            in_entry=1 
            next 
        }
        in_entry {
            if ($0 ~ /^}/) {
                in_entry=0
                count++
                if (count == 1) label="SONIC_A"
                else if (count == 2) label="SONIC_B"
                else label="SONIC_OLD_" count
                
                print "menuentry '"'"'" label "'"'"' {"
                print body
                print "}"
                body=""
            } else {
                body = body $0 "\n"
            }
        }
      ' "${existing_cfg}" >> "$grub_cfg"
  fi

  # Append State Machine logic (standard)
  if [ -n "${bootloader_state_machine:-}" ] && [ -r "${bootloader_state_machine}" ]; then
      cat "${bootloader_state_machine}" >> "$grub_cfg"
      cat <<EOF >> "$grub_cfg"
load_state
compute_state
save_state
EOF
  else
      # If we merged, we might not want default=0 if we want SONIE to be default?
      # Or if we want SONIC_A to be default?
      # Usually default=0 picks first entry.
      # If we put SONIC_A first, it will be default.
      if [ -z "${bootloader_state_machine:-}" ]; then
          echo "WARN: bootloader_state_machine file not found: ${bootloader_state_machine:-}"
          echo "set default=0" >> "$grub_cfg"
      fi
  fi

  if [ "${sonie_type:-}" = "DIAG" ] ; then
    cat <<EOF >> "$grub_cfg"
set default=ONIE
EOF
  fi

  cat <<EOF >> "$grub_cfg"
menuentry 'SONIE' {
  search --no-floppy --label --set=root ${sonie_volume_label}
  chainloader $uki_path
}
EOF
  
  # If we merged, we likely want to overwrite the EXISTING config in ESP with our NEW merged config
  if [ -n "${existing_cfg}" ] && [ -f "${existing_cfg}" ]; then
      log_info "Overwriting existing config at ${existing_cfg} with merged config"
      cp "${grub_cfg}" "${existing_cfg}"
  fi

  echo "GRUB installation complete."
}

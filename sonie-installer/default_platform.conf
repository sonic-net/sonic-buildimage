#!/bin/sh
################################################################################
# default_platform.conf
#
# Default platform implementation for the SONiE installer.
#
# This script is sourced by install.sh and provides the default implementations
# for platform-specific operations such as:
#   - Initializing console settings
#   - Partitioning the storage device
#   - Creating and mounting filesystems
#   - Installing the bootloader
#   - Configuring the bootloader menu
#
# Functions defined here can be overridden by specific platform configurations
# if needed, but this file serves as the baseline for most generic UEFI
# platforms.
#
# Globals:
#   CONSOLE_PORT (string): Serial console port (default: 0x3f8)
#   CONSOLE_SPEED (string): Serial console speed (default: 9600)
#   CONSOLE_DEV (string): Serial console device index (default: 0)
#   sonie_part_size (int): Size of the SONIE partition in MB
#   sonie_volume_label (string): Label for the SONIE partition
#   sonie_volume_revision_label (string): Revision-specific label
#   sonie_mnt (string): Mount point for the SONIE partition
#   sonie_part_num (int): Partition number for SONIE
#   sonie_type (string): Installation type (OS, DIAG, etc.)
#   install_env (string): Current installation environment (onie, sonic, build, sonie)
#   onie_bin (string): Path to ONIE binary
#   onie_initrd_tmp (string): Path to ONIE initrd temporary directory
#   onie_root_dir (string): Root directory of ONIE
#   firmware (string): Firmware type (uefi, bios)
#   image_dir (string): Directory for the image
#   FILESYSTEM_SQUASHFS (string): Name of the squashfs file
#   VAR_LOG_SIZE (int): Size of /var/log
#   check_var_log_size (function): Function to check log size
################################################################################


#######################################
# Initializes console settings (port, speed, dev) from defaults or kernel cmdline.
# Globals:
#   CONSOLE_PORT
#   CONSOLE_DEV
#   CONSOLE_SPEED
# Arguments:
#   None
# Returns:
#   None
#######################################
init_console_settings() {
  local cmdline
  if [ -r /proc/cmdline ]; then
    cmdline=$(cat /proc/cmdline)
  else
    cmdline=""
  fi
  if [ -z "${CONSOLE_PORT:-}" ]; then
    local console_ttys
    console_ttys=$(echo "$cmdline" | grep -Eo 'console=ttyS[0-9]+' | cut -d "=" -f2 | head -n 1)
    case "$console_ttys" in
      "ttyS1")
        CONSOLE_PORT=0x2f8
        CONSOLE_DEV=1
        ;;
      "ttyS2")
        CONSOLE_PORT=0x3e8
        CONSOLE_DEV=2
        ;;
      "ttyS3")
        CONSOLE_PORT=0x2e8
        CONSOLE_DEV=3
        ;;
      *)
        # Default to ttyS0
        CONSOLE_PORT=0x3f8
        CONSOLE_DEV=0
        ;;
    esac
  fi
  if [ -z "${CONSOLE_SPEED:-}" ]; then
    local speed
    speed=$(echo "$cmdline" | grep -Eo 'console=ttyS[0-9]+,[0-9]+' | cut -d "," -f2 | head -n 1)
    CONSOLE_SPEED="${speed:-9600}"
  fi
  # Export these so they are available to the caller
  export CONSOLE_PORT CONSOLE_DEV CONSOLE_SPEED
}
init_console_settings

#######################################
# Resolves the parent block device from a partition name.
# Globals:
#   None
# Arguments:
#   part_path: Path or name of the partition (e.g., /dev/sda1)
# Outputs:
#   Writes the parent block device path to stdout.
#######################################
find_device_from_partdev() {
  local partdev="${1##*/}"
  local sys_base="${SYSFS_BASE:-/sys/class/block}"
  # Check if sysfs exists for this device
  if [ -d "${sys_base}/${partdev}" ]; then
    # Go to sysfs directory, cd up one level to find parent, and print its name
    # shell check disable=SC2005
    echo "/dev/$(cd -P "${sys_base}/${partdev}" && cd .. && echo "${PWD##*/}")"
  fi
}
#######################################
# Constructs a partition device path from a block device and partition number.
# Handles suffix logic (e.g., nvme0n1 -> nvme0n1p1, sda -> sda1).
# Globals:
#   None
# Arguments:
#   dev: Block device path (e.g., /dev/sda, /dev/nvme0n1)
#   num: Partition number
# Outputs:
#   Writes the partition device path to stdout.
#######################################
make_partition_dev() {
  local dev="$1"
  local num="$2"
  case "$dev" in
    *[0-9]) echo "${dev}p${num}" ;;
    *) echo "${dev}${num}" ;;
  esac
}

#######################################
# Detects the primary block device for installation.
# Globals:
#   blk_dev
#   discovery_dev
#   cur_part
# Arguments:
#   None
#######################################
detect_block_device() {
  discovery_dev=$(blkid -o export | awk -F= '
    $1 == "DEVNAME" { dev = $2 }
    ($1 == "LABEL" || $1 == "PARTLABEL") && $2 ~ /^(ONIE-BOOT|XBOOTLDR|SONIE-)/ { print dev; exit }
  ')

  # Robustly determine block device from partition using sysfs
  if [ -n "$discovery_dev" ]; then
    blk_dev=$(find_device_from_partdev "$discovery_dev")
  fi

  # Fallback detection for empty/corrupted disk if blkid failed
  if [ -z "$blk_dev" ]; then
    for dev in /dev/sda /dev/vda /dev/nvme0n1; do
      if [ -b "$dev" ]; then
        blk_dev="$dev"
        echo "Detected fallback device: $blk_dev"
        break
      fi
    done
  fi

  [ -b "$blk_dev" ] || {
    echo "Error: Unable to determine block device of ONIE install"
    exit 1
  }

  # Note: ONIE has no mount setting for / with device node, so below will be empty string
  cur_part=""
  if [ -r /proc/mounts ]; then
    cur_part=$(awk -v bd="$blk_dev" '$2=="/" && $1 ~ bd {print $1}' /proc/mounts)
  fi
}

#######################################
# Checks if the detected block device requires reformatting.
# Globals:
#   discovery_dev
#   blk_dev
# Arguments:
#   None
# Returns:
#   0 if formatting is needed, 1 otherwise.
#######################################
disk_needs_formatting() {
  # If we found an existing ONIE/SONiC partition, the table is valid.
  if [ -n "$discovery_dev" ]; then
    return 1
  fi

  # Check if partition table is valid using sgdisk
  if verify_out=$(sgdisk -v "$blk_dev" 2>&1) && ! echo "$verify_out" | grep -q 'entries is 0 bytes'; then
    echo "Partition table valid."
    return 1
  fi

  echo "Partition table invalid or unknown."
  return 0
}

#######################################
# Creates the necessary partitions for SONIE installation.
# Auto-detects ONIE/SONIE device or falls back to standard block devices.
# Globals:
#   install_env
#   onie_bin
#   firmware
#   blk_dev
# Arguments:
#   None
# Returns:
#   None
#######################################
create_partition() {
  if [ "$install_env" = "build" ]; then
    return
  fi

  detect_block_device

  # auto-detect whether BIOS or UEFI
  if [ -d "/sys/firmware/efi/efivars" ] ; then
    firmware="uefi"
  else
    echo "Error: BIOS is unsupported"
    exit 1
  fi

  if [ "$install_env" = "onie" ] || [ "$install_env" = "sonie" ] || [ "$install_env" = "sonic" ]; then
    if disk_needs_formatting; then
      echo "Reformatting ${blk_dev}..."
      sgdisk -Z "$blk_dev"
      sgdisk -o "$blk_dev"
    fi
    ensure_esp_partition "$blk_dev"
    create_sonie_uefi_partition "$blk_dev"
  fi
}

#######################################
# Ensures an EFI System Partition (ESP) exists.
# Creates it at partition 1 if missing.
# Globals:
#   None
# Arguments:
#   blk_dev: Block device
# Returns:
#   None
#######################################
ensure_esp_partition() {
  local blk_dev="$1"
  local esp_part=""

  # Check if ESP exists (type ef00)
  esp_part=$(sgdisk -p "$blk_dev" | grep "EF00" | awk '{print $1}')

  if [ -n "$esp_part" ]; then
    echo "ESP found at partition $esp_part"
    # Ensure it has the correct label
    local esp_dev=$(make_partition_dev "$blk_dev" "$esp_part")
    local current_label=$(blkid -s LABEL -o value "$esp_dev" || true)

    if [ "$current_label" != "ESP" ]; then
        echo "Updating ESP label from '${current_label}' to 'ESP'..."
        if command -v fatlabel >/dev/null; then
            fatlabel "$esp_dev" "ESP" || echo "Warning: Failed to set ESP label"
        elif command -v dosfslabel >/dev/null; then
            dosfslabel "$esp_dev" "ESP" || echo "Warning: Failed to set ESP label"
        else
            echo "Warning: fatlabel/dosfslabel not found, cannot update label."
        fi
    fi

    # Ensure partition label is ESP
    local current_part_label
    current_part_label=$(sgdisk -i "$esp_part" "$blk_dev" | grep "Partition name:" | sed "s/.*'\(.*\)'.*/\1/")
    if [ "$current_part_label" != "ESP" ]; then
        echo "Updating ESP partition label from '${current_part_label}' to 'ESP'..."
        sgdisk -c "$esp_part":"ESP" "$blk_dev"
        partprobe_safe "$blk_dev" || true
    fi
    return
  fi

  echo "ESP not found. Creating new ESP at partition 1..."

  # Check if partition 1 is available or if we can overwrite it
  # We refrain from robustly checking overlapping, assuming standard empty/clean disk or
  # a disk where we can take partition 1.

  # Create ESP at partition 1: 200MB, type ef00
  sgdisk -n 1:2048:+200M -c 1:"ESP" -t 1:ef00 "$blk_dev" || {
      # If detecting collision, we might try to delete it first if it's not a critical partition?
      # For now, let's assume we can force it if sgdisk fails or if we want to be aggressive:
      echo "Failed to create ESP. Attempting to force delete partition 1 and retry..."
      sgdisk -d 1 "$blk_dev" || true
      sgdisk -n 1:2048:+200M -c 1:"ESP" -t 1:ef00 "$blk_dev" || {
         echo "Error: Unable to create ESP on $blk_dev"
         exit 1
      }
  }

  partprobe_safe "$blk_dev" || true

  # Format as FAT32
  if [ -x "$(command -v mkfs.vfat)" ]; then
    esp_dev=$(make_partition_dev "$blk_dev" 1)
    mkfs.vfat -F 32 -n "ESP" "$esp_dev"
  fi
}
#######################################
# Mounts the sonie partition and prepares it for installation.
# Globals:
#   blk_dev
#   sonie_part
#   sonie_mnt
#   sonie_volume_label
# Arguments:
#   None
# Returns:
#   None
#######################################
mount_partition() {
  local sonie_dev
  sonie_dev=$(make_partition_dev "$blk_dev" "$sonie_part")

  # Try to preserve existing grub.cfg if it exists
  local backup_cfg=""
  local tmp_mnt
  tmp_mnt=$(mktemp -d)

  echo "Checking for existing config in $sonie_dev before formatting..."
  if mount -t vfat "$sonie_dev" "$tmp_mnt" >/dev/null 2>&1 || mount "$sonie_dev" "$tmp_mnt" >/dev/null 2>&1; then
      local found_cfg
      found_cfg=$(find "$tmp_mnt" -name grub.cfg | head -n 1)
      if [ -n "$found_cfg" ]; then
          backup_cfg=$(mktemp)
          cp "$found_cfg" "$backup_cfg"
          echo "Backed up existing grub.cfg to $backup_cfg"
      fi
      umount "$tmp_mnt"
  fi
  rmdir "$tmp_mnt"

  # Ensure partition is unmounted before formatting
  # Retry loop to robustly unmount (handling multiple mounts or stubborn processes)
  local retries=0
  local max_retries=10
  while grep -qs "$sonie_dev" /proc/mounts; do
      echo "Partition $sonie_dev detected in /proc/mounts. Unmounting (Attempt $((retries+1))/$max_retries)..."

      # Attempt unmount
      umount "$sonie_dev" || true

      # Check if still mounted
      if grep -qs "$sonie_dev" /proc/mounts; then
           # If still mounted, maybe busy?
           local mnt_points
           mnt_points=$(awk -v dev="$sonie_dev" '$1 == dev {print $2}' /proc/mounts)
           echo "Mount points for $sonie_dev: $mnt_points"

           # Check for fuser using onie_bin if available or direct
           local fuser_cmd="fuser"
           if [ -n "${onie_bin:-}" ]; then fuser_cmd="${onie_bin} fuser"; fi

           if command -v $fuser_cmd >/dev/null 2>&1; then
                $fuser_cmd -km "$sonie_dev" || true
           fi
           sleep 1
      fi

      retries=$((retries+1))
      if [ "$retries" -ge "$max_retries" ]; then
          echo "Error: Failed to unmount $sonie_dev after $max_retries attempts."
          grep "$sonie_dev" /proc/mounts
          exit 1
      fi
  done

  # Make filesystem
  log_info "Formatting $sonie_dev as FAT32 with label $sonie_volume_label"
  mkfs.vfat -F 32 -n "$sonie_volume_label" "$sonie_dev"
  # Mount sonie filesystem
  sonie_mnt=$(${onie_bin} mktemp -d) || {
    echo "Error: Unable to create file system mount point"
    exit 1
  }
  trap_push "${onie_bin} fuser -km $sonie_mnt || ${onie_bin} umount $sonie_mnt || ${onie_bin} rmdir $sonie_mnt || true"
  ${onie_bin} mount -t vfat -o defaults,rw,umask=0000 "$sonie_dev" "$sonie_mnt" || {
    echo "Error: Unable to mount $sonie_dev on $sonie_mnt"
    exit 1
  }

  # Restore config if backup exists
  if [ -n "$backup_cfg" ] && [ -f "$backup_cfg" ]; then
      mkdir -p "$sonie_mnt/grub"
      cp "$backup_cfg" "$sonie_mnt/grub/grub.cfg"
      echo "Restored existing grub.cfg to $sonie_mnt/grub/grub.cfg for merging"
      rm "$backup_cfg"
  fi
}

sonie_part=""
#######################################
# Creates a GPT partition for the sonie OS.
# Handles partition re-use and cleanup of collisions (by label).
# Globals:
#   sonie_volume_label
#   sonie_part
# Arguments:
#   blk_dev (string): Block device (e.g. /dev/sda)
# Returns:
#   None
#######################################
create_sonie_gpt_partition() {
  local blk_dev="$1"
  local sonie_partitions
  local reuse_part=""

  # Search for SONIE-OS, or XBOOTLDR partitions to remove duplicates
  sonie_partitions=$(sgdisk -p "$blk_dev" | grep -e "$sonie_volume_label" -e "XBOOTLDR" | awk '{print $1}')

  if [ -n "$sonie_partitions" ] ; then
    # Check if we can reuse an existing XBOOTLDR partition
    for part_index in $sonie_partitions; do
      if [ "$(make_partition_dev "$blk_dev" "$part_index")" = "$cur_part" ]; then continue; fi

      # Check label
      local part_label
      part_label=$(sgdisk -i "$part_index" "$blk_dev" | grep "Partition name:" | sed "s/.*'\(.*\)'.*/\1/")

      # Only reuse if label is explicitly XBOOTLDR
      if [ "$part_label" = "XBOOTLDR" ]; then
        # Check size
        local part_sectors
        local sector_size
        local part_size_mb

        # Extract sectors - "Partition size: 123456 sectors ..."
        part_sectors=$(sgdisk -i "$part_index" "$blk_dev" | grep "Partition size:" | awk '{print $3}')

        # Get sector size (default 512 if not found, though sgdisk usually reports it)
        sector_size=$(sgdisk -p "$blk_dev" | grep "Sector size" | awk -F: '{print $2}' | awk -F/ '{print $1}' | tr -d ' ')
        sector_size=${sector_size:-512}

        # Calculate MB: sectors * sector_size / 1024 / 1024
        part_size_mb=$(( (part_sectors * sector_size) / 1048576 ))

        echo "Found XBOOTLDR partition $part_index: ${part_size_mb} MB (Required: ${sonie_part_size} MB)"

        if [ "$part_size_mb" -ge "$sonie_part_size" ]; then
           echo "Reusing existing XBOOTLDR partition $part_index"
           reuse_part="$part_index"
           break
        fi
      fi
    done

    # delete existing partitions (duplicates or too small)
    for part_index in $sonie_partitions; do
      if [ "$(make_partition_dev "$blk_dev" "$part_index")" = "$cur_part" ]; then continue; fi

      # Skip our chosen reuse partition
      if [ "$part_index" = "$reuse_part" ]; then continue; fi

      echo "deleting partition $part_index ..."
      # Try to umount regardless of /proc/mounts check to handle aliasing/symlinks
      umount "$(make_partition_dev "$blk_dev" "$part_index")" >/dev/null 2>&1 || true

      # Double check if still mounted (optional, but safer)
      if grep -qs "$(make_partition_dev "$blk_dev" "$part_index")" /proc/mounts; then
         echo "Warning: Partition $part_index still appears mounted!"
      fi
      sgdisk -d "$part_index" "$blk_dev" || {
        echo "Error: Unable to delete partition $part_index on $blk_dev"
        exit 1
      }
      partprobe_safe "$blk_dev" || {
        echo "Error: Unable to partprobe"
      }
    done
  fi

  local part_label="XBOOTLDR"
  local part_type="ea00"
  local attr_bitmask="0x0"
  if [ "$sonie_type" = "DIAG" ] ; then
    # set the GPT 'system partition' attribute bit for the DIAG
    # partition.
    attr_bitmask="0x1"
  fi

  if [ -n "$reuse_part" ]; then
    sonie_part="$reuse_part"
    echo "Updating reused partition $sonie_part attributes..."
  else
    local all_part
    # ASSUME: there are no more than 99999 partitions in a block device
    all_part=$(sgdisk -p "$blk_dev" | awk "{if (\$1 > 0 && \$1 <= 99999) print \$1}")
    # Find next available partition
    local used_part
    sonie_part=1
    for used_part in $all_part; do
      # echo "Partition #$used_part is in use."
      # skip if used_part is empty or not a number
      [ -z "$used_part" ] || [ -z "${used_part##*[!0-9]*}" ] && continue
      if [ "$used_part" -ne "$sonie_part" ]; then break; fi
      sonie_part=$((sonie_part + 1))
    done
    echo "Partition #$sonie_part is available"

    echo "Creating new $part_label partition $(make_partition_dev "$blk_dev" "$sonie_part") (Type: $part_type) ..."

    # Create new partition
    # Try preferred partition number first
    if ! sgdisk --new=${sonie_part}::+${sonie_part_size}MB \
      --attributes=${sonie_part}:=:$attr_bitmask \
      --typecode=${sonie_part}:$part_type \
      --change-name=${sonie_part}:$part_label "$blk_dev"; then
           echo "Warning: The first trial of creating partition failed, trying the largest aligned available block of sectors on the disk"
      local begin end
      begin=$(sgdisk -F "$blk_dev")
      end=$(sgdisk -E "$blk_dev")
      sgdisk --new=${sonie_part}:$begin:$end \
        --attributes=${sonie_part}:=:$attr_bitmask \
        --typecode=${sonie_part}:$part_type \
        --change-name=${sonie_part}:$part_label "$blk_dev" || {
        echo "Error: Unable to create partition $sonie_part on $blk_dev"
        exit 1
      }
    fi
  fi

  # Always update name and attributes for partition to ensure they are correct (redundant but safe)
  sgdisk --attributes=${sonie_part}:=:$attr_bitmask \
     --typecode=${sonie_part}:$part_type \
     --change-name=${sonie_part}:$part_label "$blk_dev" || true
  partprobe_safe "$blk_dev" || true
}
#######################################
# Creates a UEFI partition by wrapping GPT creation and cleaning boot vars.
# Globals:
#   sonie_volume_label
# Arguments:
#   blk_dev (string): Block device
# Returns:
#   None
#######################################
create_sonie_uefi_partition() {
  create_sonie_gpt_partition "$1"
  # erase any related EFI BootOrder variables from NVRAM.
  # Clean up current label, plus legacy labels (ACS-OS, SONiC-OS) and ONIE (replacing bootloader).
  # Skip cleanup if running in Sonie environment to preserve existing boot entries
  for b in $(efibootmgr | grep -e "$sonie_volume_label" -e "ACS-OS" -e "SONiC-OS" -e "ONIE" | awk '{ print $1 }') ; do
    local num=${b#Boot}
    efibootmgr -b $num -B > /dev/null 2>&1 || true
  done
}

#######################################
# Installs GRUB to the EFI System Partition (ESP).
# Arguments:
#   blk_dev (string): Block device
#   esp_mnt (string): ESP mount point
#   os_mnt (string): OS partition mount point
# Returns:
#   None
#######################################
install_grub_to_esp() {
  local blk_dev="$1"
  local esp_mnt="$2"
  local os_mnt="$3"
  echo "Installing GRUB to ESP at $esp_mnt..."

  local nvram_arg=""
  if [ "${install_env}" != "sonie" ]; then
     nvram_arg="--no-nvram"
  fi

  echo "Current EFI Boot Manager entries:"
  if command -v efibootmgr >/dev/null; then
      efibootmgr -v || true
  else
      echo "efibootmgr not found."
  fi

  local grub_modules_dir="${os_mnt}/grub/x86_64-efi"
  local directory_arg=""
  if [ -d "${grub_modules_dir}" ]; then
      # Copy modules to temp directory to avoid src == dst issues for grub-install
      local tmp_mod_dir
      tmp_mod_dir=$(mktemp -d)
      cp -r "${grub_modules_dir}/"* "${tmp_mod_dir}/"
      directory_arg="--directory=${tmp_mod_dir}"
      mount
  elif [ -d "${os_mnt}/usr/lib/grub/x86_64-efi" ]; then
       # Copy modules to temp directory to avoid src == dst issues for grub-install
       local tmp_mod_dir
       tmp_mod_dir=$(mktemp -d)
       cp -r "${os_mnt}/usr/lib/grub/x86_64-efi/"* "${tmp_mod_dir}/"
       directory_arg="--directory=${tmp_mod_dir}"
  fi

  # shellcheck disable=SC2086
  grub-install --target=x86_64-efi \
      "--efi-directory=${esp_mnt}" \
      "--boot-directory=${os_mnt}" \
      "--bootloader-id=${sonie_volume_label}" \
      --recheck \
      "--modules=part_gpt part_msdos" \
      "--disable-shim-lock" \
      ${nvram_arg} \
      ${directory_arg} \
      "$blk_dev"

  echo "Current EFI Boot Manager entries:"
  if command -v efibootmgr >/dev/null; then
      efibootmgr -v || true
  else
      echo "efibootmgr not found."
  fi

  # Create sonie_env to support proper state machine and sonic-installer detection
  local sonie_env="${esp_mnt}/sonie_env"
  if [ ! -f "${sonie_env}" ]; then
      echo "Creating default sonie_env at ${sonie_env}..."
      grub-editenv "${sonie_env}" create
      grub-editenv "${sonie_env}" set bootcount_env=2
      grub-editenv "${sonie_env}" set rollback_env=0
      grub-editenv "${sonie_env}" set install_env=0
      grub-editenv "${sonie_env}" set warmboot_env=0
  fi

  echo "Generating GRUB config..."
  local grub_cfg="$os_mnt/grub/grub.cfg"

  # Find UKI in OS partition
  local uki_path="/linux.efi"
  # Exclude grubx64.efi to avoid chainloading loop
  local found_uki=$(find "$os_mnt" -maxdepth 1 \( -name "*.efi" -o -name "*.bin" \) ! -name "grubx64.efi" -type f | head -n 1)
  if [ -n "$found_uki" ]; then
    uki_path="/$(basename "$found_uki")"
  fi

  # Helper: Read platform settings
  local CPUVENDOR=""
  if [ -r /proc/cpuinfo ]; then
    CPUVENDOR=$(grep -m 1 vendor_id /proc/cpuinfo | awk '{print $3}')
  fi

  local CSTATES=""
  if echo "$CPUVENDOR" | grep -iq 'Intel'; then
    CSTATES="processor.max_cstate=1 intel_idle.max_cstate=0"
  fi

  # Setup defaults corresponding to platform.conf expectations
  local DEFAULT_GRUB_SERIAL_COMMAND="serial --port=${CONSOLE_PORT:-0x3f8} --speed=${CONSOLE_SPEED:-115200} --word=8 --parity=no --stop=1"
  local DEFAULT_GRUB_CMDLINE_LINUX="console=tty0 console=ttyS${CONSOLE_DEV:-0},${CONSOLE_SPEED:-115200}n8 quiet $CSTATES"

  # Use globals if set, else default
  GRUB_SERIAL_COMMAND="${GRUB_SERIAL_COMMAND:-$DEFAULT_GRUB_SERIAL_COMMAND}"
  GRUB_CMDLINE_LINUX="${GRUB_CMDLINE_LINUX:-$DEFAULT_GRUB_CMDLINE_LINUX}"

  export GRUB_SERIAL_COMMAND
  export GRUB_CMDLINE_LINUX

  # Determine if we should merge with existing config
  local existing_cfg=""
  local merge_source=""
  if [ "${install_env}" != "build" ]; then
      # Look for existing grub.cfg in XBOOTLDR (os_mnt) to merge with
      # We might be overwriting the very file we want to merge from, so we must handle that.
      existing_cfg=$(find "${os_mnt}" -name grub.cfg 2>/dev/null | head -n 1)

      if [ -f "${existing_cfg}" ]; then
          log_info "Found existing config at ${existing_cfg}"
          # If existing config is the same file we are about to write, back it up for reading
          if [ "$(readlink -f "${existing_cfg}")" = "$(readlink -f "${grub_cfg}")" ]; then
              merge_source="$(mktemp)"
              cp "${existing_cfg}" "${merge_source}"
              log_info "Backed up existing config to ${merge_source} for merging"
          else
              merge_source="${existing_cfg}"
          fi
      else
         log_warn "No existing grub.cfg found in XBOOTLDR to merge."
      fi
  fi

  echo "Writing base configuration to $grub_cfg..."
  # Write Header
  cat <<EOF > "$grub_cfg"
$GRUB_SERIAL_COMMAND
insmod chain
terminal_input serial
terminal_output serial
set timeout=5
EOF
  echo "Wrote header."

  # Merge Existing Entries if found
  if [ -n "${merge_source}" ] && [ -f "${merge_source}" ]; then
      echo "Merging entries from ${merge_source}..."
      # Parse and extract bodies
      # We use awk to extract bodies of 'menuentry ... {' blocks
      # We ignore the label in the file and relabel them SONIC_A, SONIC_B
      awk '
        BEGIN { count=0 }
        /^menuentry / {
            # Extract the raw label e.g. "SONIE" from menuentry "SONIE" {
            # $2 is usually the label (quoted)
            raw_label=$2
            gsub(/[\x27"]/, "", raw_label)

            if (raw_label == "SONIE" || raw_label == "ONIE") {
                # Skip SONIE/ONIE entries as they are re-added by the installer
                in_entry=0
                skip=1
            } else {
                in_entry=1
                skip=0
            }
            next
        }
        skip {
            # Consuming skipped entry
            if ($0 ~ /^}/) {
                skip=0
            }
            next
        }
        in_entry {
            if ($0 ~ /^}/) {
                in_entry=0
                count++
                if (count == 1) label="SONIC_A"
                else if (count == 2) label="SONIC_B"
                else label="SONIC_OLD_" count

                print "menuentry \x27" label "\x27 {"
                print body
                print "}"
                body=""
            } else {
                body = body $0 "\n"
            }
        }
      ' "${merge_source}" >> "$grub_cfg"
      echo "Merged entries."

      # Cleanup temp merge source if it was a temp file (starts with /tmp)
      case "${merge_source}" in
          /tmp*) rm -f "${merge_source}" ;;
      esac
  fi

  # Append State Machine logic (standard)
  if [ -n "${bootloader_state_machine:-}" ] && [ -r "${bootloader_state_machine}" ]; then
      echo "Appending state machine logic..."
      cat "${bootloader_state_machine}" >> "$grub_cfg"
      cat <<EOF >> "$grub_cfg"
load_state
compute_state
save_state
EOF
  else
      # If we merged, we might not want default=0 if we want SONIE to be default?
      # Or if we want SONIC_A to be default?
      # Usually default=0 picks first entry.
      # If we put SONIC_A first, it will be default.

      # Fix logic: If bootloader_state_machine is missing OR not readable
      if [ -n "${bootloader_state_machine:-}" ]; then
           echo "WARN: bootloader_state_machine defined but not readable: ${bootloader_state_machine}"
      fi
      echo "set default=0" >> "$grub_cfg"
      echo "Set default=0 (no state machine)"
  fi

  if [ "${sonie_type:-}" = "DIAG" ] ; then
    cat <<EOF >> "$grub_cfg"
set default=ONIE
EOF
  fi

  echo "Appending SONIE menu entry..."
  cat <<EOF >> "$grub_cfg"
menuentry 'SONIE' {
  search --no-floppy --label --set=root ${sonie_volume_label}
  chainloader $uki_path
}
EOF
  echo "Appended SONIE entry."
  sync

  # Generate STUB config for ESP
  # This config points to the real config in the SONIE-OS partition (XBOOTLDR)
  local stub_cfg_content
  stub_cfg_content="search --no-floppy --label --set=root ${sonie_volume_label}
set prefix=(\$root)/grub
configfile (\$root)/grub/grub.cfg"

  local esp_dir="${esp_mnt}/EFI/${sonie_volume_label}"
  mkdir -p "${esp_dir}"
  echo "$stub_cfg_content" > "${esp_dir}/grub.cfg"
  echo "Created stub grub.cfg at ${esp_dir}/grub.cfg"

  # Also update fallback config if we are updating fallback bootloader
  local fallback_cfg_dir="${esp_mnt}/EFI/BOOT"
  mkdir -p "${fallback_cfg_dir}"
  echo "$stub_cfg_content" > "${fallback_cfg_dir}/grub.cfg"
  echo "Created fallback stub grub.cfg at ${fallback_cfg_dir}/grub.cfg"

  echo "GRUB installation complete."

  # Ensure we use the signed monolithic binary if available
  # Payload zip -j flattens structure, so check root first
  local signed_grub="${os_mnt}/grubx64.efi"
  if [ ! -f "${signed_grub}" ]; then
      # Fallback to full path if zip structure changes
      signed_grub="${os_mnt}/usr/lib/grub/x86_64-efi/monolithic/grubx64.efi"
  fi
  local fallback_target="${esp_mnt}/EFI/BOOT/BOOTX64.EFI"
  local primary_target="${esp_mnt}/EFI/${sonie_volume_label}/grubx64.efi"

  mkdir -p "$(dirname "$fallback_target")"

  if [ -f "${signed_grub}" ]; then
      echo "Found signed Grub binary at ${signed_grub}. Enforcing signed bootloader..."

      # Overwrite the one installed by grub-install (if it exists or directory exists)
      if [ -d "$(dirname "$primary_target")" ]; then
          cp "${signed_grub}" "${primary_target}"
          echo "Overwrote ${primary_target}"
      fi

      # Update fallback
      cp "${signed_grub}" "${fallback_target}"
      echo "Updated fallback bootloader at ${fallback_target}"
  else
      log_warn "Signed Grub binary not found at ${signed_grub}. Falling back to installed binary."

      # Fallback: Find installed grubx64.efi regardless of directory name
      local installed_efi
      installed_efi=$(find "${esp_mnt}/EFI" -name "grubx64.efi" | head -n 1)

      if [ -n "${installed_efi}" ] && [ -f "${installed_efi}" ]; then
          echo "Creating fallback bootloader: cp ${installed_efi} -> ${fallback_target}"
          cp "${installed_efi}" "${fallback_target}"
      else
          log_warn "Could not find grubx64.efi in ${esp_mnt}/EFI to create fallback bootloader."
      fi
  fi

  # Copy /grub configuration/modules/fonts if they exist in the payload
  # The payload unzips `grub` into ${os_mnt}/grub
  if [ -d "${os_mnt}/grub" ]; then
      echo "Deploying /grub to ${os_mnt}/grub..."
      echo "/grub is present."
  else
      # If payload didn't include it or structure mismatch
      log_warn "/grub not found in payload extraction. Standard grub-install might have populated it?"
  fi
}

#######################################
# Configures the bootloader menu by installing GRUB to ESP.
# Globals:
#   blk_dev
#   sonie_mnt
#   demo_mnt (from install.sh)
#   onie_bin (from install.sh/onie)
# Arguments:
#   None
# Returns:
#   None
#######################################
bootloader_menu_config() {
  local esp_mnt
  local esp_dev
  local os_mnt="${sonie_mnt:-${demo_mnt}}"

  if [ -z "$os_mnt" ]; then
      echo "Error: OS mount point not defined (sonie_mnt or demo_mnt)." >&2
      return 1
  fi

  # Ensure block device is detected
  if [ -z "$blk_dev" ]; then
      detect_block_device
  fi

  if [ -z "$blk_dev" ]; then
      echo "Error: Block device not found." >&2
      return 1
  fi

  esp_dev=$(make_partition_dev "$blk_dev" 1)

  # Use mktemp from onie_bin if available (for ONIE/SONIE env)
  if [ -n "${onie_bin:-}" ]; then
      esp_mnt=$( mktemp -d)
  else
      esp_mnt=$(mktemp -d)
  fi

  if [ -z "$esp_mnt" ]; then
      echo "Error: Failed to create temp dir for ESP mount" >&2
      return 1
  fi

  echo "Mounting ESP $esp_dev to $esp_mnt..."
  # Try mounting vfat
  local mount_cmd="mount"
  if [ -n "${onie_bin:-}" ]; then mount_cmd="${onie_bin} mount"; fi

  $mount_cmd -t vfat "$esp_dev" "$esp_mnt" || {
      echo "Error: Failed to mount ESP $esp_dev" >&2
      if [ -n "${onie_bin:-}" ]; then ${onie_bin} rmdir "$esp_mnt"; else rmdir "$esp_mnt"; fi
      return 1
  }

  # install_grub_to_esp <blk_dev> <esp_mnt> <os_mnt>
  install_grub_to_esp "$blk_dev" "$esp_mnt" "$os_mnt"

  local umount_cmd="umount"
  if [ -n "${onie_bin:-}" ]; then umount_cmd="${onie_bin} umount"; fi
  $umount_cmd "$esp_mnt"

  if [ -n "${onie_bin:-}" ]; then ${onie_bin} rmdir "$esp_mnt"; else rmdir "$esp_mnt"; fi
}

from dataclasses import dataclass
from typing import List, Dict, Optional
import json
from jinja2 import Environment, FileSystemLoader, select_autoescape
import os
import shutil
import logging
from swsscommon import swsscommon
from sonic_py_common import syslogger

SYSLOG_IDENTIFIER = "hwsku-init"
LOG = syslogger.SysLogger(SYSLOG_IDENTIFIER, enable_runtime_config=False, log_level=logging.DEBUG)

# Force this LOG instance to always print to console
# Since the hwsku-init runs before syslog is up, they need to go to console
_syslog_log = LOG.log
def _log_with_console(priority, msg, also_print_to_console=False):
    return _syslog_log(priority, msg, also_print_to_console=True)
LOG.log = _log_with_console

'''
Data types for parsing the input files
'''
@dataclass
class AsicPort:
    core: int
    pm: int
    lanes: List[int]

@dataclass
class GearboxPort:
    gearbox_id: int
    gearbox_init_mode: str
    host_lanes: List[int]
    line_lanes: List[int]
    logical_host_lanes: Optional[List[int]] = None
    logical_line_lanes: Optional[List[int]] = None

@dataclass
class PortSpeedProfile:
    name: str
    speed: int                      # in Gbps
    asic: AsicPort
    gearbox: Optional[GearboxPort] = None

@dataclass
class PortConfigDbEntry:
    alias: str
    speed: int
    index: int
    lanes: List[int]

@dataclass(frozen=True)
class ASICLaneKey:
    core: int
    pm: int
    port_name: str

PortSpeedMap = Dict[int, List[PortSpeedProfile]]    # port_index -> [speed_profiles]
ConfigDbPortMap = Dict[str, PortConfigDbEntry]      # port_name -> PortConfigDbEntry
ASICLaneMap = Dict[ASICLaneKey, List[int]]          # ASICLaneKey -> [lanes...]

@dataclass
class SKURawInputs:
    port_speed: PortSpeedMap
    asic_lanes: ASICLaneMap
    config_db: Dict[str, object]

'''
Data types for the SKU configuration
'''
@dataclass
class SKUGearboxConfig:
    name: str
    index: int
    phy_id: int
    system_lanes: List[int]
    line_lanes: List[int]

@dataclass
class SKUPortPhyConfig:
    index: int
    system_speed: int
    line_speed: int

SKUPortPhyFiles = Dict[str, List[SKUPortPhyConfig]] # phy config file name -> SKUPortPhyConfig

class SkuBasePipeline:

    def __init__(
        self,
        speed_map_file: str,
        asic_lane_file: str,
        config_db_file: Optional[str]=None
    ):
        self.port_speed_map = self.load_port_speed_map(speed_map_file)
        self.asic_lane_map  = self.load_asic_file(asic_lane_file)
        if config_db_file:
            self.config_db = self.read_config_from_file(config_db_file)
        else:
            self.config_db = self.read_config_db()

    def load_port_speed_map(self, path: str) -> PortSpeedMap:
        """
        Load platform port speed map from JSON file.
        The JSON file is generated by the platform team and contains the port speed
        information for all supported port speeds for a given platform.  This information
        is used to initialize the platform specific port configuration.
        """
        with open(path, "r") as f:
            raw = json.load(f)

        port_speed_map: PortSpeedMap = {}

        for port_index_str, speed_profiles in raw.items():
            port_index = int(port_index_str)
            port_speed_map[port_index] = []

            for speed_str, profile in speed_profiles.items():
                # Support keys like "100G" and "100G-4" by normalizing to the numeric
                # speed (Gbps) based on the part before 'G'. Both will have the same
                # speed value but are kept as separate profiles.
                base_speed_str = speed_str.split("G", 1)[0]
                speed = int(base_speed_str)

                asic = AsicPort(
                    core=profile["asic"]["core"],
                    pm=profile["asic"]["pm"],
                    lanes=profile["asic"]["lanes"],
                )

                gearbox = None
                if "gearbox" in profile:
                    gearbox = GearboxPort(
                        gearbox_id=profile["gearbox"]["gearbox_id"],
                        gearbox_init_mode=profile["gearbox"]["gearbox_init_mode"],
                        host_lanes=profile["gearbox"]["host_lanes"],
                        line_lanes=profile["gearbox"]["line_lanes"],
                        logical_host_lanes=profile["gearbox"].get("logical_host_lanes"),
                        logical_line_lanes=profile["gearbox"].get("logical_line_lanes"),
                    )

                name = profile["name"]
                port_speed_map[port_index].append(
                    PortSpeedProfile(
                        name=name,
                        speed=speed,
                        asic=asic,
                        gearbox=gearbox,
                    )
                )
        LOG.log_info(f"Loaded port speed map: {port_speed_map}")
        return port_speed_map

    def load_asic_file(self, path: str) -> ASICLaneMap:
        with open(path, "r") as f:
            raw = json.load(f)
        lanes = raw.get("PM", {})
        asic_map: ASICLaneMap = {}
        for core_str, pm_dict in lanes.items():
            core = int(core_str)
            for pm_str, ports in pm_dict.items():
                pm = int(pm_str)
                for port_name, ls in ports.items():
                    key = ASICLaneKey(core=core, pm=pm, port_name=port_name)
                    asic_map[key] = list(ls)
        LOG.log_info(f"Loaded asic lane map: {asic_map}")
        return asic_map

    def read_config_db(self):
        """Read all PORT entries from CONFIG_DB and return a mapping.

        Uses swsscommon DBConnector and Table to access the PORT table.

        Returns a dictionary like:
            {
                "Ethernet0": {"alias": "etp1", "speed": "400000", ...},
                ...
            }
        """
        db = swsscommon.DBConnector("CONFIG_DB", 0)
        tbl = swsscommon.Table(db, "PORT")

        port_map: ConfigDbPortMap = {}
        for k in tbl.getKeys():
            ok_alias, alias = tbl.hget(k, "alias")
            ok_speed, speed_str = tbl.hget(k, "speed")
            ok_index, index_str = tbl.hget(k, "index")
            ok_lanes, lanes_str = tbl.hget(k, "lanes")

            if not (ok_alias and ok_speed and ok_index and ok_lanes):
                raise RuntimeError(f"Incomplete PORT entry for {k}")

            port_map[k] = PortConfigDbEntry(
                alias=alias,
                speed=int(speed_str) // 1000,               # 400000 -> 400 (Gbps)
                index=int(index_str),
                lanes=[int(n) for n in lanes_str.split(",")]
            )
        LOG.log_info(f"Loaded config db: {port_map}")
        return port_map

    def read_config_from_file(self, path: str) -> ConfigDbPortMap:
        """Read PORT entries from a config DB JSON file.

        The file is expected to have a structure like:
            {
                "PORT": {
                    "Ethernet0": {
                        "alias": "etp1",
                        "speed": "400000",
                        "index": "1",
                        "lanes": "96,97,98,99",
                        ...
                    },
                    ...
                },
                ...
            }

        Returns the same data type as :meth:`read_config_db`, i.e.
        ConfigDbPortMap (mapping port name -> PortConfigDbEntry).
        """

        with open(path, "r") as f:
            raw = json.load(f)

        if "PORT" not in raw or not isinstance(raw["PORT"], dict):
            raise RuntimeError(f"PORT table not found in config DB file {path}")

        port_table = raw["PORT"]
        port_map: ConfigDbPortMap = {}

        for port_name, attrs in port_table.items():
            try:
                alias = attrs["alias"]
                speed_str = attrs["speed"]
                index_str = attrs["index"]
                lanes_val = attrs["lanes"]
            except KeyError as e:
                raise RuntimeError(f"Incomplete PORT entry for {port_name} in {path}: missing {e.args[0]}") from e

            # Lanes may be represented either as a comma-separated string
            # (e.g. "96,97,98,99") or as a list of integers/strings.
            if isinstance(lanes_val, list):
                lanes = [int(n) for n in lanes_val]
            else:
                lanes = [int(n) for n in str(lanes_val).split(",") if str(n).strip()]

            port_map[port_name] = PortConfigDbEntry(
                alias=alias,
                speed=int(speed_str) // 1000,   # 400000 -> 400 (Gbps), match read_config_db()
                index=int(index_str),
                lanes=lanes,
            )

        return port_map

    def generate_sonic_gearbox_config(self) -> List[SKUGearboxConfig]:
        gearbox_port_entrys: List[SKUGearboxConfig] = []
        # Iterate over config_db
        for port_name, port_cfg in self.config_db.items():
            port_index = port_cfg.index
            if port_index not in self.port_speed_map:
                continue
            # Find the speed profile for this port
            port_speed = port_cfg.speed
            port_lanes = port_cfg.lanes
            port_speed_profiles = self.port_speed_map[port_index]

            for speed_profile in port_speed_profiles:
                if speed_profile.speed == port_speed and speed_profile.asic.lanes == port_lanes:
                    break
            else:
                raise Exception(
                    f"Failed to find speed profile for port {port_name} (index {port_index}) with speed {port_speed}"
                )

            # Now update the SKUGearboxConfig based on the found speed profile
            if speed_profile.gearbox is None:
                continue

            gearbox_port_entrys.append(SKUGearboxConfig(
                name=speed_profile.name,
                index=port_index,
                phy_id=speed_profile.gearbox.gearbox_id,
                system_lanes=speed_profile.gearbox.host_lanes,
                line_lanes=speed_profile.gearbox.line_lanes
            ))
        LOG.log_info(f"Generated gearbox config: {gearbox_port_entrys}")
        return gearbox_port_entrys

    def generate_sonic_phy_config(self) -> SKUPortPhyFiles:
        # Create files per phy following the format phy<phy_id>_config.json
        phy_files: SKUPortPhyFiles = {}

        for port_name, port_cfg in self.config_db.items():
            port_index = port_cfg.index
            if port_index not in self.port_speed_map:
                continue
            # Find the speed profile for this port
            port_speed = port_cfg.speed
            port_lanes = port_cfg.lanes
            port_speed_profiles = self.port_speed_map[port_index]

            for speed_profile in port_speed_profiles:
                if speed_profile.speed == port_speed and speed_profile.asic.lanes == port_lanes:
                    break
            else:
                raise Exception(
                    f"Failed to find speed profile for port {port_name} (index {port_index}) with speed {port_speed}"
                )

            if speed_profile.gearbox is None:
                continue

            phy_id = speed_profile.gearbox.gearbox_id
            phy_files.setdefault(f"phy{phy_id}_config.json", []).append(
                SKUPortPhyConfig(
                    index=port_index,
                    system_speed=(speed_profile.speed * 1000) // len(speed_profile.gearbox.host_lanes),
                    line_speed=(speed_profile.speed * 1000) // len(speed_profile.gearbox.line_lanes),
                )
            )
        LOG.log_info(f"Generated phy config: {phy_files}") 
        return phy_files

    def generate_plat_asic_config(self):
        raise NotImplementedError("generate_plat_asic_config() not implemented")

    def generate_plat_gearbox_config(self):
        raise NotImplementedError("generate_plat_gearbox_config() not implemented")

    def run(
        self,
        template_dir: str,
        output_dir: str,
        defaults_dir: str,
        asic_bcm_template: str,
        gearbox_template: Optional[str] = None,
    ) -> None:
        try:
            asic_cfg = self.generate_plat_asic_config()
            # Currently we do not support generating gearbox bcm config
            # gb_plat_cfg = self.generate_plat_gearbox_config()
            sonic_gb = self.generate_sonic_gearbox_config()
            sonic_phy = self.generate_sonic_phy_config()
            env = Environment(loader=FileSystemLoader(template_dir),
                              autoescape=select_autoescape(["html", "xml"]))
            if gearbox_template:
                env.get_template(gearbox_template).stream(interfaces=sonic_gb).dump(
                    os.path.join(output_dir, "gearbox_config.json")
                )
                # Generate multiple phy config files
                for phy_file, phy_cfg in sonic_phy.items():
                    env.get_template("phy_config.json.j2").stream(ports=phy_cfg).dump(
                        os.path.join(output_dir, phy_file)
                    )
            env.get_template(asic_bcm_template).stream(ports_config=asic_cfg).dump(
                os.path.join(output_dir, os.path.splitext(asic_bcm_template)[0])
            )
        except Exception as e:
            LOG.log_error(f"Error: {e}, {e.__traceback__}")
            LOG.log_info("copying the defaults...")
            # Copy everything from defaults folder to hwsku
            for file in os.listdir(defaults_dir):
                shutil.copy(
                    os.path.join(defaults_dir, file), os.path.join(output_dir, file)
                )
